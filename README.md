# 🚀 Algorithm Journey (算法进阶之路)

> **Keep coding, stay hungry.**
> 记录我攻克 LeetCode 和《剑指 Offer》的刷题历程。
> 重点关注：算法思维、代码规范以及 Java 底层实现。

## 🛠 技术栈 (Tech Stack)
- **Language:** Java 8+
- **Tool:** IntelliJ IDEA
- **Topics:** 数据结构、递归回溯、动态规划、位运算、双指针等。

## 📚 刷题进度 (Solutions)

## 📚 刷题进度 (Solutions by Topic)

### 🧊 数组 & 双指针 (Array & Two Pointers)
| 编号 | 题目 | 核心考点 | 难度 | 题解 |
| :--- | :--- | :--- | :--- | :--- |
| LC 1 | 两数之和 | 哈希表 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/array/LC1_TwoSum.java) |
| LCR 120 | 寻找文件副本 | 原地交换 (哈希) | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/array/LCR120_FindRepeatNumber.java) |
| LCR 121 | 寻找目标值 - 二维数组 | 线性查找 / 降维 | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/array/LCR121_FindNumberIn2DArray.java) |
| LCR 128 | 库存管理 I | 二分查找 (变种) | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/array/LCR128_StockManagement.java) |
| LCR 135 | 报数 | 数组循环 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/array/LCR135_CountNumbers.java) |
| LCR 139 | 训练计划 I | 双指针 (奇偶交换) | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/array/LCR139_TrainingPlanI.java) |

### 🔗 链表 (LinkedList)
| 编号 | 题目 | 核心考点 | 难度 | 题解 |
| :--- | :--- | :--- | :--- | :--- |
| LC 206 | 反转链表 | 迭代 / 双指针 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/linkedlist/LC206_ReverseList.java) |
| LCR 140 | 训练计划 II (倒数第k个) | 快慢指针 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/linkedlist/LCR140_TrainingPlanII.java) |
| LCR 142 | 训练计划 IV (合并链表) | 伪头节点 (Dummy) | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/linkedlist/LCR142_TrainingPlanIV.java) |

### 🥞 栈与队列 (Stack & Queue)
| 编号 | 题目 | 核心考点 | 难度 | 题解 |
| :--- | :--- | :--- | :--- | :--- |
| LC 20 | 有效的括号 | 栈匹配 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/stackqueue/LC20_ValidParentheses.java) |
| LCR 123 | 图书整理 I (倒序打印) | 栈 (先进后出) | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/stackqueue/LCR123_ReversePrint.java) |
| LCR 125 | 图书整理 II (双栈队列) | 栈与队列转换 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/stackqueue/LCR125_CQueue.java) |
| LCR 147 | 最小栈 | 辅助栈 / 差值法 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/stackqueue/LCR147_MinStack.java) |

### 🌲 二叉树 (Binary Tree)
| 编号 | 题目 | 核心考点 | 难度 | 题解 |
| :--- | :--- | :--- | :--- | :--- |
| LC 144 | 前序遍历 | 递归 / 迭代 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/tree/LC144_PreorderTraversal.java) |
| LCR 124 | 推理二叉树 | 递归 / 分治 | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/tree/LCR124_DeduceTree.java) |
| LCR 143 | 子结构判断 | 双重递归 | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/tree/LCR143_SubStructure.java) |
| LCR 144 | 翻转二叉树 | 递归交换 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/tree/LCR144_FlipTree.java) |
| LCR 145 | 判断对称二叉树 | 递归 (双指针) | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/tree/LCR145_SymmetricTree.java) |
| LCR 149 | 彩灯装饰记录 I | BFS (队列) | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/tree/LCR149_LevelOrder.java) |
| LCR 150 | 彩灯装饰记录 II | BFS (分层) | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/tree/LCR150_LevelOrderII.java) |
| LCR 151 | 彩灯装饰记录 III | BFS (Z字形/双栈) | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/tree/LCR151_LevelOrderIII.java) |

### 🔙 回溯与 DFS (Backtracking)
| 编号 | 题目 | 核心考点 | 难度 | 题解 |
| :--- | :--- | :--- | :--- | :--- |
| LC 113 | 路径总和 II | 路径记录 / 回溯 | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/backtracking/LC113_PathSumII.java) |
| LCR 157 | 套餐内商品的排列顺序 | 全排列 / 交换法 | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/backtracking/LCR157_Permutation.java) |
| LCR 129 | 字母迷宫 | 矩阵 DFS / 标记 | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/backtracking/LCR129_WordSearch.java) |

### 🎭 动态规划 (Dynamic Programming)
| 编号 | 题目 | 核心考点 | 难度 | 题解 |
| :--- | :--- | :--- | :--- | :--- |
| LCR 126 | 斐波那契数 | 滚动数组 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/dp/LCR126_Fibonacci.java) |
| LCR 127 | 跳跃训练 | 爬楼梯模型 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/dp/LCR127_JumpFloor.java) |
| LCR 161 | 连续天数的最高销售额 | 贪心 / 前缀和 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/dp/LCR161_MaxSubArray.java) |
| LCR 166 | 珠宝的最高价值 | 二维 DP | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/dp/LCR166_JewelleryValue.java) |

### 📶 排序 (Sorting)
| 编号 | 题目 | 核心考点 | 难度 | 题解 |
| :--- | :--- | :--- | :--- | :--- |
| LCR 158 | 库存管理 II | 摩尔投票法 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/sort/LCR158_MajorityElement.java) |
| LCR 159 | 库存管理 III | 堆 (Top K) | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/sort/LCR159_GetLeastNumbers.java) |
| LCR 164 | 破解闯关密码 | 自定义排序 / 快排 | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/sort/LCR164_CrackPassword.java) |

### 🔢 位运算 (Bit Manipulation)
| 编号 | 题目 | 核心考点 | 难度 | 题解 |
| :--- | :--- | :--- | :--- | :--- |
| LCR 133 | 位 1 的个数 | `n & (n-1)` | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/bit/LCR133_HammingWeight.java) |
| LCR 190 | 加密运算 | 加法器原理 | 简单 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/bit/LCR190_EncryptionCalculate.java) |
| LCR 134 | Pow(x, n) | 快速幂 | 中等 | [Code](./src/main/java/com/lxy/leetcode/swordoffer/bit/LCR134_MyPow.java) |


## 💡 核心知识笔记 (Key Takeaways)

> 这里的每一个总结，都对应着一类经典算法题的通解。

### 1. 链表与数组 (Linked List & Array)
- **伪头节点 (Dummy Node)**：
    - 解决链表处理中“头节点可能变化”的问题（如合并链表、删除节点）。
    - *Code Pattern:* `ListNode dummy = new ListNode(0); ListNode cur = dummy;`
- **快慢指针 (Fast/Slow Pointers)**：
    - 解决“倒数第k个节点”、“链表中点”、“判断环”等问题。
    - *Trick:* 让快指针先走 k 步，或者快指针速度是慢指针的 2 倍。
- **原地哈希 (In-place Swap)**：
    - 在 `O(1)` 空间下解决“数组中重复数字”问题。
    - *Core:* 努力让 `nums[i] == i`，如果不相等就不断交换。

### 2. 栈与队列 (Stack & Queue)
- **双栈法**：
    - **实现队列**：InStack 负责进，OutStack 负责出（懒惰搬运，OutStack 空了才搬）。
    - **Z字形打印二叉树**：利用两个栈的“先进后出”特性控制打印顺序。
- **辅助栈 (Min Stack)**：
    - 在 O(1) 时间内获取栈的最小值。
    - *Strategy:* 辅助栈同步存入当前的最小值（非严格降序）。

### 3. 二叉树 (Binary Tree)
- **递归 (DFS)**：
    - 树的核心思维。重点在于定义函数的“宏观语义”，而非纠结细节。
    - *Template:* `Terminator` (终止条件) -> `Process` (处理当前) -> `Recursion` (递归左右)。
- **层序遍历 (BFS)**：
    - 核心数据结构是 **队列 (Queue)**。
    - *Key:* 利用 `int size = queue.size()` 来锁定当前层的节点数量，实现**分层打印**。

### 4. 回溯算法 (Backtracking)
- **通用模板**：
    - 解决排列、组合、路径搜索（迷宫）问题。
    - *Pattern:*
      ```java
      void backtrack(路径, 选择列表) {
          if (满足结束条件) {
              res.add(new ArrayList<>(路径)); // 注意拷贝
              return;
          }
          for (选择 : 选择列表) {
              做选择;
              backtrack(路径, 选择列表);
              撤销选择; // 回溯的核心
          }
      }
      ```

### 5. 动态规划 (Dynamic Programming)
- **滚动数组 (Rolling Array)**：
    - 将空间复杂度从 `O(N)` 优化至 `O(1)`（如斐波那契、跳台阶）。
    - *Code:* `sum = (a + b); a = b; b = sum;`
- **前缀和与贪心**：
    - 解决“最大子数组和”问题。核心思维是“甩包袱”：如果之前的累加和 < 0，则直接丢弃，从当前开始计算。
- **网格 DP**：
    - 解决“矩阵路径最大值”问题。
    - *Equation:* `dp[i][j] += max(dp[i-1][j], dp[i][j-1])`

### 6. 排序与查找 (Sorting & Search)
- **二分查找 (Binary Search)**：
    - 处理有序（或部分有序/旋转）数组。注意边界条件 `left <= right` 还是 `left < right`。
- **Top K 问题**：
    - 使用 **堆 (PriorityQueue)**。找最小 K 个用大根堆，找最大 K 个用小根堆。
    - 时间复杂度：`O(N log K)`。
- **自定义排序**：
    - 解决“拼接最小数”问题。
    - *Rule:* `(x + y).compareTo(y + x)`

### 7. 位运算 (Bit Manipulation)
- **消除二进制中最后一个 1**：
    - 公式：`n = n & (n - 1)`
    - 应用：统计二进制中 1 的个数，判断是否为 2 的幂。

- **计算机加法原理**：
    - **异或 (`^`)**：相当于“无进位加法”（1+1=0, 1+0=1）。
    - **与 (`&`) + 左移 (`<<`)**：相当于“计算进位”。
    - 循环直到进位为 0。

- **快速幂 (Binary Exponentiation)**：
    - 将 $x^n$ 的计算复杂度从 $O(N)$ 降至 $O(\log N)$。
    - 核心思想是利用二进制拆分指数，让底数不断翻倍（$x \to x^2 \to x^4$）。
    - 从大到小，体会分治思想，如果指数是偶数，则结果为 $x^n = x^{n/2} * x^{n/2}$；如果指数是奇数，则结果为 $x^n = x^{n/2} * x^{n/2} * x$。
---
*Created by Lxy | Last Update: 2025-11-28*